package echonet

import (
	"bytes"
	"testing"
)

func TestPacket(t *testing.T) {
	e := []byte{
		0x10, 0x81, // EHD
		0x12, 0x34, // TID
		0x11, 0x22, 0x33, // SEOJ
		0xaa, 0xbb, 0xcc, // DEOJ
		0x60,             // ESV
		0x02,             // OPC
		0x80, 0x01, 0x30, // EPC,PDC,EDT
		0xa0, 0x01, 0x41, // EPC,PDC,EDT
	}

	pkt := NewEchonetPacket()
	pkt.SetTid(0x1234)
	pkt.SetSeoj(0x112233)
	pkt.SetDeoj(0xaabbcc)
	pkt.SetEsv(ESV_SETI)
	pkt.AddProperty(EPC_POWER, EDT_ON)
	pkt.AddProperty(EPC_FAN, EDT_AUTO)

	b := pkt.Bytes()
	if !bytes.Equal(b, e) {
		t.Errorf("packet result %+v expect %+v\n", b, e)
	}

	pkt.Parse(e)
	p := pkt.Bytes()
	if !bytes.Equal(b, p) {
		t.Errorf("packet result %+v expect %+v\n", b, p)
	}
}

func TestProperty(t *testing.T) {
	prop := EchonetProperty{
		EPC: 0x9f,
		PDC: 0x11,
		EDT: []byte{0x18,
			0x0d, 0x11, 0x01, 0x0f, 0x19, 0x01, 0x00, 0x00,
			0x01, 0x01, 0x09, 0x08, 0x00, 0x02, 0x0a, 0x03},
	}

	m := getPropertyMap(prop)
	e := []byte{0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x88, 0x89, 0x8a, 0x8f,
		0x93, 0x9d, 0x9e, 0x9f, 0xa0, 0xa3,
		0xb0, 0xb3, 0xb4, 0xba, 0xbb, 0xbe, 0xc1, 0xc4}
	if !bytes.Equal(m, e) {
		t.Errorf("property result %+v expect %+v\n", m, e)
	}
}
